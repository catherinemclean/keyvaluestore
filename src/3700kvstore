#!/usr/bin/env python

import json
import select
import sys
import time

from replica import Replica
from constants import *

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

rep = Replica(my_id, replica_ids)

while True:
	ready = select.select([rep.sock], [], [], 0.1)[0]

	if rep.sock in ready:
		msg_raw = rep.sock.recv(32768)

		if len(msg_raw) == 0: continue
		msg = json.loads(msg_raw)
		msg_type = msg['type']

		if rep.current_state == LEADER:
			if msg_type in [GET, PUT]:
				rep.send_append_ent(msg)

			elif msg_type == OK:
				rep.handle_ok(msg)

			elif msg_type == FAIL:
				rep.handle_fail(msg)

			elif msg_type == VOTE_REPLY and msg['term'] > rep.current_term:
				rep.current_term = msg['term']
				continue # if already leader, could just be delayed vote, so just ignore
				#rep.become_follower()

			elif msg_type == VOTE_REQ:
				rep.become_follower()
				rep.handle_vote_request(msg)

			elif msg_type == APPEND_ENT:
				if (msg['term'] > rep.current_term):
					rep.become_follower()
					rep.recv_append_ent(msg)


		else: # either follower or candidate
			# Redirect get() and put() from clients to leader
			if msg_type in [GET, PUT]:
				rep.redirect_client(msg)

			elif msg_type == APPEND_ENT:
				rep.recv_append_ent(msg)

			elif msg_type == VOTE_REQ:
				rep.handle_vote_request(msg)

			elif msg_type == VOTE_REPLY:
				if msg['vote']:
					if rep.current_state == CANDIDATE:
						rep.tally_votes()
				else:
					if msg['term'] > rep.current_term:
						rep.current_term = msg['term']
						#rep.become_follower()


	clock = time.time()
	if rep.current_state == LEADER:
		if clock - rep.append_last > .1:
			rep.send_append_ent()

	#checks if received an Append RPC message in election timeout frame
	elif clock - rep.last > rep.election_timeout:
		rep.become_candidate()

